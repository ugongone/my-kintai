# フェーズ3: 認証機能実装

## 概要

Supabase AuthとGoogle OAuthを使用した認証機能を実装しました。ユーザーはGoogleアカウントでログインでき、未認証ユーザーは自動的にログインページにリダイレクトされます。

## 実装内容

### 1. Supabaseクライアント設定

#### ブラウザ用クライアント ([src/lib/supabase/client.ts](../../src/lib/supabase/client.ts))
- `@supabase/ssr`の`createBrowserClient`を使用
- クライアントサイドでSupabaseにアクセスするための設定
- 環境変数から`NEXT_PUBLIC_SUPABASE_URL`と`NEXT_PUBLIC_SUPABASE_ANON_KEY`を取得

#### サーバー用クライアント ([src/lib/supabase/server.ts](../../src/lib/supabase/server.ts))
- `@supabase/ssr`の`createServerClient`を使用
- Server ComponentsやRoute Handlersで使用
- Next.jsのcookies APIを統合してセッション管理
- `getAll()`でcookieを取得、`setAll()`でcookieを設定

### 2. 認証ページ

#### ログインページ ([src/app/login/page.tsx](../../src/app/login/page.tsx))
- Googleログインボタンを配置
- アプリロゴ（Briefcaseアイコン）と説明を表示
- 既にログイン済みの場合はホームページにリダイレクト
- Tailwind CSSでレスポンシブなデザインを実装

#### ログイン処理 ([src/app/auth/login/route.ts](../../src/app/auth/login/route.ts))
- POST Route Handlerで実装
- `signInWithOAuth`メソッドでGoogle OAuthフローを開始
- コールバックURLを`/auth/callback`に設定
- エラー時はログインページにリダイレクト

#### 認証コールバック ([src/app/auth/callback/route.ts](../../src/app/auth/callback/route.ts))
- GET Route Handlerで実装
- Googleからのリダイレクトでcodeパラメータを受け取る
- `exchangeCodeForSession`でcodeをセッショントークンに交換
- 認証後はホームページにリダイレクト

### 3. 認証ミドルウェア ([src/middleware.ts](../../src/middleware.ts))

- すべてのリクエストで認証状態をチェック
- 未認証ユーザーが保護されたページにアクセスした場合、`/login`にリダイレクト
- 認証済みユーザーが`/login`にアクセスした場合、`/`にリダイレクト
- `/auth`パスは認証チェックから除外（無限ループ防止）
- 静的ファイル（画像、フォントなど）は認証チェックから除外

### 4. 認証フック ([src/hooks/useAuth.ts](../../src/hooks/useAuth.ts))

- クライアントコンポーネントで使用するカスタムフック
- `user`: 現在のユーザー情報
- `loading`: ローディング状態
- `signOut`: ログアウト処理
- `onAuthStateChange`でリアルタイムに認証状態を監視

## Q&A

### Q1: `@supabase/ssr`を使う理由は?

<details>
<summary>回答を見る</summary>

Next.js App RouterのServer ComponentsとクライアントコンポーネントでSupabaseを使い分けるため。
- Server Components: `createServerClient`でcookieベースのセッション管理
- Client Components: `createBrowserClient`でブラウザのlocalStorage/cookieを使用

従来の`@supabase/auth-helpers-nextjs`はPages Router向けで、App Routerでは`@supabase/ssr`が推奨されています。
</details>

### Q2: middlewareでcookieを2回設定している理由は?

<details>
<summary>回答を見る</summary>

```typescript
cookiesToSet.forEach(({ name, value, options }) =>
  request.cookies.set(name, value)
)
supabaseResponse = NextResponse.next({ request })
cookiesToSet.forEach(({ name, value, options }) =>
  supabaseResponse.cookies.set(name, value, options)
)
```

1回目: リクエストオブジェクトに設定（後続のミドルウェアやハンドラーで使用可能に）
2回目: レスポンスオブジェクトに設定（ブラウザに送信するcookieを更新）

これにより、セッションの更新が正しく反映されます。
</details>

### Q3: `useAuth`フックの`useEffect`のcleanup関数の役割は?

<details>
<summary>回答を見る</summary>

```typescript
return () => {
  subscription.unsubscribe()
}
```

`onAuthStateChange`で作成したサブスクリプションをクリーンアップするため。
コンポーネントがアンマウントされたときにサブスクリプションを解除しないと、メモリリークが発生します。
</details>

### Q4: ログインページで既にログイン済みかチェックする理由は?

<details>
<summary>回答を見る</summary>

```typescript
const { data } = await supabase.auth.getUser()
if (data?.user) {
  redirect('/')
}
```

ログイン済みのユーザーが誤ってログインページにアクセスした場合、すぐにホームページにリダイレクトしてUXを向上させるため。middlewareでもチェックしていますが、Server Componentで二重チェックすることで確実性を高めています。
</details>

### Q5: middlewareのmatcher設定の意味は?

<details>
<summary>回答を見る</summary>

```typescript
matcher: [
  '/((?!_next/static|_next/image|favicon.ico|.*\\.(?:svg|png|jpg|jpeg|gif|webp)$).*)',
]
```

この正規表現は以下のパスを**除外**します:
- `_next/static`: Next.jsの静的ファイル
- `_next/image`: Next.js Image Optimization
- `favicon.ico`: ファビコン
- 画像ファイル（svg, png, jpg, jpeg, gif, webp）

これらのパスで認証チェックを行うと、不要なデータベースアクセスが発生してパフォーマンスが低下するため除外します。
</details>
