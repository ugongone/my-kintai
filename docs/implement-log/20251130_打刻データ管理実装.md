# フェーズ6: 打刻データ管理実装

## 概要

Supabaseと連携して、実際の打刻データの保存・取得・計算機能を実装しました。これによりアプリケーションが完全に動作するようになります。

## 実装内容

### 1. 打刻データフック ([src/hooks/useTimeEntries.ts](../../src/hooks/useTimeEntries.ts))

**機能:**
- 今月の打刻データを自動取得
- 打刻の追加・更新・削除
- リアルタイムでデータを再取得

**データ取得:**
```tsx
const fetchEntries = async () => {
  const now = new Date()
  const firstDay = new Date(now.getFullYear(), now.getMonth(), 1)
  const lastDay = new Date(now.getFullYear(), now.getMonth() + 1, 0)

  const { data, error } = await supabase
    .from('time_entries')
    .select('*')
    .eq('user_id', user.id)
    .gte('entry_time', firstDay.toISOString())
    .lte('entry_time', lastDay.toISOString())
    .order('entry_time', { ascending: false })
}
```

今月の初日から最終日までのデータを降順で取得します。

**打刻追加:**
```tsx
const addEntry = async (entryType: EntryType, entryTime?: Date, note?: string) => {
  const time = entryTime || new Date()

  const { data, error } = await supabase
    .from('time_entries')
    .insert({
      user_id: user.id,
      entry_type: entryType,
      entry_time: time.toISOString(),
      note,
    })
    .select()
    .single()

  await fetchEntries()
}
```

打刻後、自動的にデータを再取得して最新状態を反映します。

### 2. 設定フック ([src/hooks/useSettings.ts](../../src/hooks/useSettings.ts))

**機能:**
- 時給設定の取得・更新
- 初回アクセス時に自動的にデフォルト設定を作成

**初期化ロジック:**
```tsx
const { data, error } = await supabase
  .from('settings')
  .select('*')
  .eq('user_id', user.id)
  .single()

if (!data) {
  // 設定がない場合はデフォルト値で作成
  const { data: newSettings } = await supabase
    .from('settings')
    .insert({
      user_id: user.id,
      hourly_rate: 1500,
    })
    .select()
    .single()
}
```

ユーザーが初めてアクセスしたときに、デフォルト時給1500円の設定を自動作成します。

### 3. ステータス計算ロジック ([src/lib/utils/workStatus.ts](../../src/lib/utils/workStatus.ts))

**getCurrentStatus: 現在のステータスを判定**
```tsx
export function getCurrentStatus(entries: TimeEntry[]): WorkStatus {
  if (entries.length === 0) return 'offline'

  const latest = entries[0]
  const latestType = latest.entry_type

  if (latestType === 'work_start' || latestType === 'break_end') {
    return 'working'
  }
  if (latestType === 'break_start') {
    return 'break'
  }
  return 'offline'
}
```

最新の打刻レコードから現在の状態を推定:
- work_start または break_end → 稼働中
- break_start → 休憩中
- work_end → 稼働外

**calculateWorkTime: 稼働時間を計算**
```tsx
export function calculateWorkTime(entries: TimeEntry[]): {
  totalMinutes: number
  breakMinutes: number
  workMinutes: number
}
```

本日の打刻データから、総稼働時間・休憩時間・実働時間を計算します。

**ロジック:**
1. 本日のエントリのみフィルタ
2. work_start から work_end までを総稼働時間に加算
3. break_start から break_end までを休憩時間に加算
4. 実働時間 = 総稼働時間 - 休憩時間

**calculateMonthlyStats: 月次統計を計算**
```tsx
export function calculateMonthlyStats(entries: TimeEntry[]): {
  totalHours: number
  totalDays: number
}
```

今月の稼働日数と総稼働時間を計算します。

### 4. ダッシュボードとの統合 ([src/app/(authenticated)/page.tsx](../../src/app/(authenticated)/page.tsx))

**データ取得:**
```tsx
const { entries, loading: entriesLoading, addEntry } = useTimeEntries()
const { settings } = useSettings()

const currentStatus = getCurrentStatus(entries)
const lastEntryTime = getLastEntryTime(entries)
const { totalHours } = calculateMonthlyStats(entries)
const estimatedEarnings = totalHours * (settings?.hourly_rate || 0)
```

**打刻ハンドラ:**
```tsx
const handlePunchIn = async () => {
  try {
    await addEntry('work_start')
  } catch (error) {
    console.error('打刻エラー:', error)
    alert('打刻に失敗しました')
  }
}
```

エラー処理を含めた安全な打刻実装。

**手動打刻:**
```tsx
const handleManualEntry = async (data: {
  date: string
  time: string
  entryType: string
  note?: string
}) => {
  try {
    const entryTime = new Date(`${data.date}T${data.time}`)
    await addEntry(data.entryType as any, entryTime, data.note)
  } catch (error) {
    console.error('手動打刻エラー:', error)
    alert('手動打刻に失敗しました')
  }
}
```

日付と時刻を組み合わせてDate objectを作成し、打刻します。

### 5. 設定ページ ([src/app/(authenticated)/settings/page.tsx](../../src/app/(authenticated)/settings/page.tsx))

**機能:**
- 現在の時給表示
- 時給更新フォーム
- 更新状態のフィードバック

**実装:**
```tsx
const { settings, loading, updateHourlyRate } = useSettings()
const [hourlyRate, setHourlyRate] = useState('')
const [isSaving, setIsSaving] = useState(false)

const handleSubmit = async (e: React.FormEvent) => {
  e.preventDefault()
  setIsSaving(true)

  try {
    await updateHourlyRate(Number(hourlyRate))
    alert('時給を更新しました')
    setHourlyRate('')
  } catch (error) {
    alert('更新に失敗しました')
  } finally {
    setIsSaving(false)
  }
}
```

## Q&A

### Q1: なぜfetchEntriesを別関数にしているのか?

<details>
<summary>回答を見る</summary>

```tsx
const fetchEntries = async () => { ... }

useEffect(() => {
  fetchEntries()
}, [user])
```

再利用性とリフレッシュ機能のため:
1. useEffect内で直接実装すると、再取得時に同じコードを書く必要がある
2. `refetch: fetchEntries`としてエクスポートすることで、外部から手動で再取得可能
3. 打刻後に自動的に`await fetchEntries()`で最新データを取得

これにより、リアルタイムでUIを更新できます。
</details>

### Q2: calculateWorkTimeのロジックで状態管理をどうしているか?

<details>
<summary>回答を見る</summary>

```tsx
let workStart: Date | null = null
let breakStart: Date | null = null

for (let i = todayEntries.length - 1; i >= 0; i--) {
  const entry = todayEntries[i]

  if (entry.entry_type === 'work_start') {
    workStart = entryTime
  } else if (entry.entry_type === 'work_end' && workStart) {
    const workDuration = (entryTime.getTime() - workStart.getTime()) / 60000
    totalMinutes += workDuration
    workStart = null
  }
}
```

古いエントリから順に処理:
1. work_start で開始時刻を記録
2. work_end で終了時刻との差分を計算して加算
3. 処理後は `workStart = null` でリセット

これにより、複数の work_start/work_end ペアを正しく処理できます。
</details>

### Q3: なぜ時給設定が存在しない場合に自動作成するのか?

<details>
<summary>回答を見る</summary>

```tsx
if (!data) {
  const { data: newSettings } = await supabase
    .from('settings')
    .insert({
      user_id: user.id,
      hourly_rate: 1500,
    })
    .select()
    .single()
}
```

UX向上のため:
1. ユーザーが初めてログインしたとき、設定画面に行かなくても動作する
2. デフォルト値(1500円)で概算報酬額が表示される
3. 後から設定画面で変更可能

これにより、初回ログイン時のオンボーディング体験が向上します。
</details>

### Q4: addEntryでentryTime引数がoptionalな理由は?

<details>
<summary>回答を見る</summary>

```tsx
const addEntry = async (entryType: EntryType, entryTime?: Date, note?: string) => {
  const time = entryTime || new Date()
}
```

2つの打刻方法に対応するため:
1. **通常の打刻**: `addEntry('work_start')` → 現在時刻で打刻
2. **手動打刻**: `addEntry('work_start', new Date('2024-01-01T09:00'))` → 指定時刻で打刻

optionalにすることで、通常打刻時に時刻を指定する必要がなく、シンプルに使えます。
</details>

### Q5: calculateMonthlyStatsで日付をMapで管理している理由は?

<details>
<summary>回答を見る</summary>

```tsx
const dailyWork = new Map<string, number>()

entries.forEach((entry) => {
  const date = new Date(entry.entry_time).toDateString()
  if (!dailyWork.has(date)) {
    dailyWork.set(date, 0)
  }
})
```

稼働日数をカウントするため:
1. 同じ日に複数の打刻があっても、Mapのキーは一意
2. `dailyWork.size`で稼働日数を簡単に取得
3. 日付ごとのグルーピングが容易

配列で管理すると重複チェックが複雑になりますが、Mapを使うことでシンプルに実装できます。
</details>

### Q6: エラーハンドリングでalert()を使う理由は?

<details>
<summary>回答を見る</summary>

```tsx
try {
  await addEntry('work_start')
} catch (error) {
  console.error('打刻エラー:', error)
  alert('打刻に失敗しました')
}
```

現時点ではシンプルなエラー通知で十分なため:
1. alert()は追加実装不要でユーザーに確実に伝わる
2. 本番環境では Toast通知などに置き換え可能
3. エラーログは console.error で記録

将来的には、より洗練されたエラー通知UIに置き換えることを推奨します。
</details>
