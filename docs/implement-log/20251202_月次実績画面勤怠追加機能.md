# 月次実績画面勤怠追加機能

## 概要
月次実績画面（HistoryTable）から直接勤怠データを追加できる機能を実装した。テーブル上部に「打刻を追加」ボタンを配置し、クリックすると入力行が表示され、日付・開始時刻・終了時刻・休憩時間を一括で入力できる。

## 実装内容

### 1. useTimeEntries.ts - 複数エントリ一括登録関数

**ファイル**: `src/hooks/useTimeEntries.ts`

`addMultipleEntries` 関数を追加し、work_start、work_end、break_start、break_endを一度に登録できるようにした。

```typescript
const addMultipleEntries = async (data: {
  date: string
  startTime: string
  endTime: string
  breakStartTime?: string
  breakEndTime?: string
}) => {
  if (!user) return

  const entriesToInsert: {
    user_id: string
    entry_type: EntryType
    entry_time: string
    work_date: string
    note?: string
  }[] = []

  // work_start, work_end を配列に追加
  const workStartTime = new Date(`${data.date}T${data.startTime}`)
  const workEndTime = new Date(`${data.date}T${data.endTime}`)

  entriesToInsert.push({
    user_id: user.id,
    entry_type: 'work_start',
    entry_time: workStartTime.toISOString(),
    work_date: calculateWorkDate(workStartTime),
  })

  entriesToInsert.push({
    user_id: user.id,
    entry_type: 'work_end',
    entry_time: workEndTime.toISOString(),
    work_date: calculateWorkDate(workEndTime),
  })

  // 休憩時間が入力されている場合は追加
  if (data.breakStartTime && data.breakEndTime) {
    const breakStartTime = new Date(`${data.date}T${data.breakStartTime}`)
    const breakEndTime = new Date(`${data.date}T${data.breakEndTime}`)

    entriesToInsert.push({
      user_id: user.id,
      entry_type: 'break_start',
      entry_time: breakStartTime.toISOString(),
      work_date: calculateWorkDate(breakStartTime),
    })

    entriesToInsert.push({
      user_id: user.id,
      entry_type: 'break_end',
      entry_time: breakEndTime.toISOString(),
      work_date: calculateWorkDate(breakEndTime),
    })
  }

  // 一括insert
  const { error } = await supabase
    .from('time_entries')
    .insert(entriesToInsert)

  if (error) {
    console.error('Error adding multiple entries:', error)
    throw error
  }

  await fetchEntries()
}
```

**ポイント**:
- Supabaseの `insert()` は配列を渡すことで複数レコードを一括登録できる
- work_dateは各エントリごとに `calculateWorkDate()` で計算
- 休憩時間はオプション（両方入力されている場合のみ登録）

### 2. AddEntryRow.tsx - 入力行コンポーネント

**ファイル**: `src/components/history/AddEntryRow.tsx` (新規作成)

テーブル内に表示される入力行コンポーネント。

```typescript
type AddEntryRowProps = {
  year: number
  month: number
  onSave: (data: {
    date: string
    startTime: string
    endTime: string
    breakStartTime?: string
    breakEndTime?: string
  }) => void
  onCancel: () => void
}
```

**入力フィールド**:
- 日付 (date input) - 表示月内かつ今日以前に制限
- 開始時刻 (time input) - デフォルト 09:00
- 終了時刻 (time input) - デフォルト 18:00
- 休憩開始 (time input) - オプション
- 休憩終了 (time input) - オプション

**バリデーション**:
- 日付・開始・終了は必須
- 終了時刻 > 開始時刻
- 休憩は開始と終了の両方を入力（片方だけはエラー）
- 休憩終了 > 休憩開始
- 休憩時間は業務時間内

**日付制約**:
```typescript
const today = new Date()
const firstDayOfMonth = new Date(year, month, 1)
const lastDayOfMonth = new Date(year, month + 1, 0)
const maxDate = lastDayOfMonth > today ? today : lastDayOfMonth

// input要素
<input
  type="date"
  min={formatDateForInput(firstDayOfMonth)}
  max={formatDateForInput(maxDate)}
/>
```

### 3. HistoryTable.tsx - ボタンと入力行の追加

**ファイル**: `src/components/history/HistoryTable.tsx`

**変更点**:
1. propsに `year`, `month`, `onAddEntry` を追加
2. `isAddingEntry` 状態を管理
3. テーブル上部に「打刻を追加」ボタンを配置
4. ボタンクリックで入力行を表示
5. データなし時も「打刻を追加」ボタンを表示

**UI構造**:
```
<div className="bg-white rounded-lg shadow overflow-hidden">
  {/* 打刻追加ボタン（入力中は非表示） */}
  {!isAddingEntry && (
    <div className="px-6 py-4 border-b border-gray-200">
      <button>打刻を追加</button>
    </div>
  )}

  <table>
    <thead>...</thead>
    <tbody>
      {/* 入力行（入力中のみ表示） */}
      {isAddingEntry && <AddEntryRow ... />}

      {/* 通常のデータ行 */}
      {stats.map(...)}
    </tbody>
  </table>
</div>
```

### 4. history/page.tsx - ハンドラ実装

**ファイル**: `src/app/(authenticated)/history/page.tsx`

`handleAddEntry` 関数を追加し、`addMultipleEntries` を呼び出す。

```typescript
const { entries, loading, updateEntry, deleteEntry, addMultipleEntries } = useTimeEntries(year, month)

const handleAddEntry = async (data: {
  date: string
  startTime: string
  endTime: string
  breakStartTime?: string
  breakEndTime?: string
}) => {
  try {
    await addMultipleEntries(data)
  } catch (error) {
    console.error('追加エラー:', error)
    alert('打刻の追加に失敗しました')
  }
}

// HistoryTableにpropsを渡す
<HistoryTable
  stats={dailyStats}
  year={year}
  month={month}
  onEditEntry={handleEditEntry}
  onDeleteEntry={handleDeleteClick}
  onAddEntry={handleAddEntry}
/>
```

## 技術的なポイント

### 1. 日付のmin/max制約
HTMLの `date` input要素の `min` と `max` 属性を使用して、選択可能な日付を制限。

- **min**: 表示月の1日
- **max**: 表示月の末日 または 今日 のどちらか早い方

### 2. バリデーションの実装
保存前にフロントエンドでバリデーションを実施し、エラーメッセージを表示。

```typescript
if (!date || !startTime || !endTime) {
  setError('日付、開始時刻、終了時刻は必須です')
  return
}

if (startTime >= endTime) {
  setError('終了時刻は開始時刻より後にしてください')
  return
}
```

### 3. work_dateの自動計算
各エントリの `work_date` は `calculateWorkDate()` 関数で自動計算される。これにより0〜4時台の勤務は前日扱いになる。

### 4. 一括insert
Supabaseの `insert()` メソッドは配列を受け取れるため、4つのエントリ（work_start, work_end, break_start, break_end）を1回のAPI呼び出しで登録できる。

## Q&A

### Q1: なぜ `addEntry` を4回呼ぶのではなく `addMultipleEntries` を作ったのか？

A: 以下の理由から専用の関数を作成した：
- **パフォーマンス**: 1回のAPI呼び出しで完結するため高速
- **整合性**: 途中でエラーが発生した場合の不整合を防げる
- **再取得の最適化**: `fetchEntries()` を1回だけ呼べば良い

### Q2: 休憩時間のバリデーションで「業務時間内」をチェックする理由は？

A: 休憩開始が業務開始より前、または休憩終了が業務終了より後になると、日次統計の計算で矛盾が生じる可能性があるため。

例:
- 業務: 09:00-18:00
- 休憩: 08:00-09:00 ← これはNG（業務開始前）

### Q3: 日付の制約で「未来の日付を許可しない」理由は？

A: 勤怠管理システムでは、実績を記録するものであり、未来の予定を入力する用途ではないため。未来の日付を許可すると、統計データに予定が含まれてしまう。

### Q4: `isAddingEntry` 状態をページではなくHistoryTableで管理している理由は？

A: 入力行の表示/非表示はテーブル内のUI状態であり、ページレベルで管理する必要がないため。コンポーネントの責務を明確にし、再利用性を高めるため。

### Q5: エラー時に `alert()` を使用している理由は？

A: 既存の実装パターン（ManualEntryModal、編集・削除機能）に合わせるため。将来的にはトースト通知などに置き換えることも検討できる。

### Q6: テーブル上部にボタンを配置した理由は？

A: ユーザーが最初に見る位置に配置することで、操作性を向上させるため。テーブル下部だとスクロールが必要になる場合がある。
