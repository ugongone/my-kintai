# 複数セッション合算機能実装

## 概要
1日に複数の勤怠セット（work_start〜work_end）がある場合に、各セッションの実働時間を正しく合算して表示できるように`calculateDailyStats`関数を改修しました。

## 実装内容

### 問題点
以前の実装では、1日の最初の`work_start`から最後の`work_end`までを1セッションとして計算していたため、複数回出勤した場合に実働時間が正しく計算されませんでした。

**例：**
```
09:00 work_start
12:00 work_end      → 実働3時間
14:00 work_start
18:00 work_end      → 実働4時間

以前：9時間（09:00-18:00全体）
現在：7時間（3時間 + 4時間）✓
```

### 解決策

#### セッション分割アルゴリズム

各日のエントリーを時系列順に処理し、`work_start`から次の`work_end`までを1セッションとして認識するように変更しました。

**アルゴリズムの流れ：**
1. エントリーを時刻順にソート
2. `work_start`を検出したらセッション開始
3. そのセッション内の`break_start`〜`break_end`を休憩時間として記録
4. `work_end`を検出したらセッション終了し、実働時間を計算
5. 次の`work_start`で新しいセッション開始
6. すべてのセッションの実働時間を合算

#### 不完全なデータの扱い

- **work_startのみでwork_endがない場合**：現在時刻までを計算（稼働中として扱う）
- **work_endのみでwork_startがない場合**：無視
- **連続するwork_start**：新しいwork_startが来たら前のセッションを現在時刻で自動終了
- **連続するwork_end**：最初のwork_endでセッション終了、2つ目以降は無視

### 変更ファイル

#### `/Users/yugo/Dev/my-kintai/src/lib/utils/dailyStats.ts`

`calculateDailyStats`関数を書き換えました。

**主な変更点：**

1. **セッション配列の導入**
```typescript
const sessions: Array<{
  workStart: Date
  workEnd: Date | null
  breakMinutes: number
  workMinutes: number
}> = []
```

2. **現在のセッションを管理**
```typescript
let currentSession: {
  workStart: Date | null
  workEnd: Date | null
  breakStart: Date | null
  breakMinutes: number
} | null = null
```

3. **work_start検出時の処理**
```typescript
if (entry.entry_type === 'work_start') {
  // 前のセッションが未完了なら現在時刻で終了
  if (currentSession && currentSession.workStart && !currentSession.workEnd) {
    const now = new Date()
    let breakMinutes = currentSession.breakMinutes
    if (currentSession.breakStart) {
      breakMinutes += (now.getTime() - currentSession.breakStart.getTime()) / 60000
    }
    const duration = (now.getTime() - currentSession.workStart.getTime()) / 60000
    sessions.push({
      workStart: currentSession.workStart,
      workEnd: null,
      breakMinutes,
      workMinutes: duration - breakMinutes
    })
  }
  // 新しいセッション開始
  currentSession = {
    workStart: entryTime,
    workEnd: null,
    breakStart: null,
    breakMinutes: 0
  }
}
```

4. **work_end検出時の処理**
```typescript
else if (entry.entry_type === 'work_end' && currentSession?.workStart) {
  currentSession.workEnd = entryTime
  const duration = (entryTime.getTime() - currentSession.workStart.getTime()) / 60000
  sessions.push({
    workStart: currentSession.workStart,
    workEnd: currentSession.workEnd,
    breakMinutes: currentSession.breakMinutes,
    workMinutes: duration - currentSession.breakMinutes
  })
  currentSession = null
}
```

5. **全セッションの合算**
```typescript
const totalBreakMinutes = sessions.reduce((sum, s) => sum + s.breakMinutes, 0)
const totalWorkMinutes = sessions.reduce((sum, s) => sum + s.workMinutes, 0)
```

6. **ステータスの判定**
```typescript
let status: DailyStat['status'] = 'no_data'
if (sessions.length > 0) {
  if (sessions.some(s => s.workEnd === null)) {
    status = 'in_progress'
  } else {
    status = 'complete'
  }
}
```

### 表示の変更

**日次統計テーブル（折りたたみ時）：**
- 開始時刻：最初のセッションの開始時刻
- 終了時刻：最後のセッションの終了時刻
- 実働時間：全セッションの合算時間
- 休憩時間：全セッションの休憩時間合算

**展開時（個別エントリー）：**
- 変更なし（すべての打刻エントリーを時系列順に表示）

### 影響範囲

**変更ファイル：**
- `src/lib/utils/dailyStats.ts` - 計算ロジックの変更のみ

**変更不要なファイル：**
- UIコンポーネント（すべて変更なし）
- APIやデータベーススキーマ（変更なし）
- 型定義（変更なし）

### 後方互換性

- 既存の1セッションのみのデータも正しく計算される
- 表示形式は変更なし
- 既存の動作を損なわない

## テストシナリオ

### シナリオ1: 1日1セッション（既存動作）
```
09:00 work_start
12:00 break_start
13:00 break_end
18:00 work_end
→ 実働: 8時間、休憩: 1時間 ✓
```

### シナリオ2: 1日2セッション
```
09:00 work_start
12:00 work_end
14:00 work_start
18:00 work_end
→ 実働: 7時間（3時間 + 4時間）✓
```

### シナリオ3: 複数セッション+休憩
```
09:00 work_start
11:00 break_start
11:30 break_end
12:00 work_end
14:00 work_start
18:00 work_end
→ 実働: 6.5時間、休憩: 0.5時間 ✓
```

### シナリオ4: 稼働中（work_endなし）
```
09:00 work_start
12:00 break_start
13:00 break_end
（現在18:00と仮定）
→ 実働: 8時間、休憩: 1時間、ステータス: 稼働中 ✓
```

### シナリオ5: 連続work_start
```
09:00 work_start
10:00 work_start  ← 新しいセッション開始、前のセッションは現在時刻で終了
12:00 work_end
→ 実働: 2時間（10:00-12:00のみ）✓
```

## Q&A

### Q1: なぜセッション単位で計算するようにしたのか？
**A:** 1日に複数回出勤するケース（例：午前中だけ勤務して午後別の仕事、夜また戻るなど）に対応するため。以前は全体の時間を計算していたため、実際に働いていない時間も含まれていた。

### Q2: 連続したwork_startがあるとどうなるのか？
**A:** 新しいwork_startが検出されると、前のセッションを現在時刻で自動的に終了させ、新しいセッションを開始する。これにより、打刻ミスがあっても最新のwork_startを優先できる。

### Q3: 表示上の変更はあるのか？
**A:** なし。日次統計テーブルの表示は従来通り「最初の開始時刻」と「最後の終了時刻」を表示。実働時間のみが正確に合算されるようになった。

### Q4: 既存のデータに影響はあるのか？
**A:** なし。1セッションのみのデータは以前と同じように計算される。複数セッションがある場合のみ、正確な合算が行われる。

### Q5: なぜUIコンポーネントの変更が不要なのか？
**A:** `DailyStat`型のインターフェースを変更していないため。計算ロジックのみを変更し、出力される型は同じなので、既存のコンポーネントはそのまま使用できる。

## 期待される効果

- 複数回出勤しても正確な実働時間が記録される
- 月次の総稼働時間・概算報酬額が正確になる
- 打刻ミス（連続work_start等）に対してロバストになる
- UIの変更が不要なため、ユーザー体験は変わらない
